<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Letter-scanner : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Letter-scanner</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/BeeShall/Letter-Scanner">View on GitHub</a>

          <h1 id="project_title">Letter-scanner</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/BeeShall/Letter-Scanner/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/BeeShall/Letter-Scanner/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p>This program uses LEGO MindStorms EV3 robot a letter scanner. It will:</p>

<h1>
<a id="serialization-of-rules" class="anchor" href="#serialization-of-rules" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Serialization of rules</h1>

<p>First, it loads a text file containing IF THEN rules. The syntax of the rules is:</p>

<p>(0,0), (0,1), (1,0), (2,0), (2,1) -&gt; C </p>

<p>(5,2), (4,3), C -&gt; G</p>

<p>where (0,0) refers to the grid coordinates of the pixels scanned by the robot. Note that:</p>

<p>The coordinates on the LHS may not be listed in any sorted order in the text file.</p>

<p>The letters in the rules may not be single-character, e.g., if we use the Greek character set, the letters may be alpha, beta, etc.</p>

<p>(0,0) refers to the top left of the pixel grid.</p>

<h1>
<a id="ai-algorithms" class="anchor" href="#ai-algorithms" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AI algorithms</h1>

<p>It offers the user the option to do forward reasoning or backward reasoning:</p>

<h2>
<a id="i-forward-reasoning" class="anchor" href="#i-forward-reasoning" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>i. Forward Reasoning:</h2>

<p>i. It compiles the rules into a binary decision tree, wherein, each node is a pixel, and its two children represent the pixel being on or off.</p>

<p>ii. It scans the pixels in an order determined by you: row-major - this will the same order used for the binary decision tree.</p>

<p>iii. After reaching each new pixel, it prints all the remaining candidates as per the decision tree, e.g., after finding that pixel (0,0) is off, the remaining candidates may be only A or I.</p>

<p>iv. It traverses the decision tree and print all the deductions, e.g., in the above example, not only that the scanned pixels ultimately represent G (a leaf node in your decision tree), but en-route, some subset also represents C (an intermediate node in the decision tree).</p>

<p>v. If the scanned pixels are not an exact match to any character in the rule base, it prints the possible candidates - these are the leaf nodes in the subtree whose root is the intermediate node where the reasoning ends. </p>

<h2>
<a id="ii-backward-reasoning" class="anchor" href="#ii-backward-reasoning" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ii. Backward Reasoning:</h2>

<p>i. It asks the user for the character that should be recognized.</p>

<p>ii. It scans only the pixels on the LHS of the rule for that character. (This could mean, considering additional rules, e.g., to recognize G, it should also consider the rule for C above).</p>

<p>iii.  The moment a pixel expected to be on is found to be off, it immediatelys report that the character was not found, and stop.</p>

<h1>
<a id="robot-behaviour" class="anchor" href="#robot-behaviour" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Robot behaviour</h1>

<h2>
<a id="calibration" class="anchor" href="#calibration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Calibration:</h2>

<p>If this choice is selected, the robot cycles through the following three inputs:</p>

<p>i. Read the ON color - you place the robot on an on strip, it reads the light sensor and saves the value</p>

<p>ii. Read the OFF color - you place the robot on an off strip, it reads the light sensor and saves the value</p>

<p>iii. Read the pixel size - you place your robot just before the pixel. It reads the distance traveled between two transitions: off-to-on and on-back-to-off. This is the size of a pixel (assumed to be square).</p>

<h2>
<a id="scan" class="anchor" href="#scan" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Scan:</h2>

<p>If this choice is selected, the robot offers two options:</p>

<h3>
<a id="forward-reasoning" class="anchor" href="#forward-reasoning" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Forward Reasoning:</h3>

<p>It scans the pixel grid in row major order. It emits three different sound patterns (with accompanying display behaviors):</p>

<ol>
<li><p>A sound every time it reads a pixel, on or off. On the screen, it displays the coordinates of the pixel it thinks it is scanning (e.g., 2 3), followed by the remaining candidates as per the decision tree;</p></li>
<li><p>A sound pattern when it successfully identifies a letter in its rule base. On the screen, it displays its deductions, i.e., all the letters represented by the pixel pattern and sub-patterns, if any;</p></li>
<li><p>A sound pattern if it fails to find any letter in its rule base. On the screen, it displays the possible candidates.</p></li>
</ol>

<h3>
<a id="backward-reasoning" class="anchor" href="#backward-reasoning" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Backward Reasoning:</h3>

<p>i. It displays the letters for which rules are provided in the rule base;</p>

<p>ii. It lets the user select the target letter using one of its buttons;</p>

<p>iii. It then proceeds to scan. It emits three sound patterns with accompanying display behaviors as follows:</p>

<ol>
<li><p>A sound every time it reads a pixel, on or off. On the screen, it displays the coordinates of the pixel it thinks it is scanning (e.g., 2 3).</p></li>
<li><p>A sound pattern when it successfully identifies a letter in its rule base. On the screen, it displays success.</p></li>
<li><p>A sound pattern if it finds a pixel to be off that should be on. On the screen, it displays failure.</p></li>
</ol>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Letter-scanner maintained by <a href="https://github.com/BeeShall">BeeShall</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
